<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Pickleball Round Robin Scheduler</title>
  <style>
    :root {
      --bg: #0b1220;
      --panel: #111a2e;
      --ink: #e5e7eb;
      --muted: #9ca3af;
      --line: #243047;
      --ok: #16a34a;
      --warn: #f59e0b;
      --bad: #ef4444;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      color: var(--ink);
      background: radial-gradient(1200px 600px at 10% -10%, #1a2a4a 0%, transparent 60%), var(--bg);
      font-family: "Avenir Next", "Segoe UI", Tahoma, sans-serif;
    }
    .wrap { max-width: 1100px; margin: 0 auto; padding: 20px; }
    h1 { margin: 0 0 12px; font-size: clamp(22px, 3vw, 34px); }
    .card {
      background: linear-gradient(180deg, #0f172b, #101b31);
      border: 1px solid var(--line);
      border-radius: 14px;
      padding: 14px;
      margin-bottom: 14px;
    }
    .grid { display: grid; gap: 10px; }
    .grid.two { grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); }
    label { display: block; font-weight: 700; margin-bottom: 6px; }
    input[type="number"], input[type="text"], textarea {
      width: 100%;
      background: #0b1325;
      color: var(--ink);
      border: 1px solid var(--line);
      border-radius: 10px;
      padding: 10px;
      font-size: 14px;
    }
    textarea { min-height: 130px; resize: vertical; }
    .hint { color: var(--muted); font-size: 12px; }
    .btns { display: flex; flex-wrap: wrap; gap: 8px; margin-top: 8px; }
    button {
      border: 0;
      border-radius: 10px;
      padding: 10px 14px;
      font-weight: 700;
      cursor: pointer;
    }
    .primary { background: linear-gradient(180deg, #22c55e, #16a34a); color: #05240f; }
    .secondary { background: linear-gradient(180deg, #475569, #334155); color: #e2e8f0; }
    .ghost { background: transparent; color: #cbd5e1; border: 1px solid #334155; }
    .row { display: flex; gap: 10px; align-items: center; flex-wrap: wrap; }
    .court-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); gap: 8px; }
    .court-row { display: grid; gap: 6px; }
    .warnings { color: var(--warn); margin-top: 8px; font-size: 13px; }
    .error { color: var(--bad); }
    details {
      background: #0d162a;
      border: 1px solid var(--line);
      border-radius: 12px;
      padding: 10px;
      margin-bottom: 10px;
    }
    summary { cursor: pointer; font-weight: 800; }
    table { width: 100%; border-collapse: collapse; margin-top: 8px; }
    th, td { border: 1px solid var(--line); padding: 8px; text-align: left; vertical-align: top; }
    th { background: #122241; }
    .tag {
      display: inline-block;
      font-weight: 800;
      font-size: 12px;
      border-radius: 999px;
      padding: 2px 8px;
      margin-right: 6px;
    }
    .serve { background: #f59e0b; color: #2b1c02; }
    .recv { background: #22c55e; color: #05240f; }
    .sit { color: #cbd5e1; margin-top: 6px; font-size: 13px; }
    .score-input { width: 90px; }
    .leader-good { color: #86efac; font-weight: 700; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, monospace; }
    .status-ok { color: #86efac; font-weight: 700; }
    .status-warn { color: #fbbf24; font-weight: 700; }
    .hidden { display: none !important; }
    .mode-btn.active {
      background: linear-gradient(180deg, #22c55e, #16a34a);
      color: #05240f;
    }

    @media print {
      :root {
        --ink: #111111;
        --line: #444444;
      }

      @page {
        size: letter portrait;
        margin: 0.5in;
      }

      body {
        background: #ffffff !important;
        color: #111111 !important;
        font-family: "Helvetica Neue", Arial, sans-serif;
        font-size: 11pt;
      }

      .wrap {
        max-width: none;
        margin: 0;
        padding: 0;
      }

      .no-print,
      #warnings,
      #leaderboardSection,
      #leaguePanel,
      #modePanel,
      #leagueStandingsSection {
        display: none !important;
      }

      .card,
      details {
        background: transparent !important;
        border: 0 !important;
        border-radius: 0 !important;
        padding: 0 !important;
        margin: 0 0 14pt !important;
      }

      summary {
        list-style: none;
        font-size: 14pt;
        font-weight: 800;
        margin: 0 0 8pt;
      }

      .round-sheet {
        break-inside: avoid;
        page-break-inside: avoid;
        margin: 0 0 14pt;
      }

      h1 {
        margin: 0 0 10pt;
        font-size: 18pt;
      }

      h3 {
        margin: 0 0 6pt;
        font-size: 13pt;
      }

      table {
        margin-top: 6pt;
      }

      th,
      td {
        border: 1px solid #444444;
        background: transparent !important;
        color: #111111 !important;
        padding: 7pt 6pt;
        font-size: 10.5pt;
      }

      .tag {
        border: 1px solid #444444;
        color: #111111 !important;
        background: transparent !important;
      }

      input.score-input {
        width: 62pt;
        min-height: 22pt;
        border: 1px solid #444444 !important;
        background: #ffffff !important;
        color: #111111 !important;
        border-radius: 0;
        padding: 0 4pt;
      }
    }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>Pickleball Round Robin Scheduler</h1>

    <div class="card no-print" id="modePanel">
      <div class="row">
        <strong>Mode:</strong>
        <button class="secondary mode-btn active" id="modeRoundRobinBtn" type="button">Round Robin</button>
        <button class="secondary mode-btn" id="modeLeagueBtn" type="button">League Play</button>
      </div>
      <div class="hint" id="modeHint" style="margin-top:8px;">Round Robin mode is active.</div>
    </div>

    <div class="card no-print hidden" id="leaguePanel">
      <h3 style="margin-top:0;">League Setup</h3>
      <div class="grid two">
        <div>
          <label for="leagueName">League name</label>
          <input id="leagueName" type="text" placeholder="Spring Ladder League" />
        </div>
        <div>
          <label for="leaguePlayerCount">League players</label>
          <input id="leaguePlayerCount" type="number" min="4" value="12" />
        </div>
      </div>
      <div style="margin-top:10px;">
        <label for="leaguePlayerNames">Player names (comma/newline)</label>
        <textarea id="leaguePlayerNames" class="mono" placeholder="Alex, Bri, Casey, Drew"></textarea>
      </div>
      <div class="btns">
        <button class="primary" id="createLeagueBtn" type="button">Create / Save League</button>
        <button class="secondary" id="loadLeagueBtn" type="button">Load League</button>
        <button class="ghost" id="clearLeagueBtn" type="button">Reset League</button>
        <button class="ghost" id="useLeaguePlayersBtn" type="button">Use League Players for Schedule</button>
      </div>
      <div id="leagueStatus" class="hint" style="margin-top:8px;">No league loaded.</div>
    </div>

    <div class="card no-print">
      <div class="grid two">
        <div>
          <label for="playerCount">Number of players</label>
          <input id="playerCount" type="number" min="4" value="12" />
          <div class="hint">Used when player names are blank. Otherwise names list controls total players.</div>
        </div>
        <div>
          <label for="courtCount">Number of courts</label>
          <input id="courtCount" type="number" min="1" value="3" />
        </div>
        <div>
          <label for="roundCount">Number of rounds</label>
          <input id="roundCount" type="number" min="1" value="5" />
        </div>
        <div>
          <label for="seed">Week #</label>
          <input id="seed" type="text" placeholder="FridayMix" />
        </div>
      </div>

      <div class="grid two" style="margin-top: 10px;">
        <div>
          <div class="row" style="justify-content: space-between;">
            <label for="playerNames" style="margin:0;">Player names (comma/newline)</label>
            <div class="btns" style="margin-top:0;">
              <button class="ghost" id="fillNumbers" type="button">Fill 1..N</button>
              <button class="ghost" id="sampleNames" type="button">Sample</button>
              <button class="ghost" id="clearNames" type="button">Clear</button>
            </div>
          </div>
          <textarea id="playerNames" class="mono" placeholder="Alex, Bri, Casey, Drew"></textarea>
          <div class="hint">Duplicates and blanks are removed.</div>
        </div>
        <div>
          <div class="row" style="justify-content: space-between;">
            <label style="margin:0;">Court names</label>
            <button class="secondary" id="autofillCourts" type="button">Autofill</button>
          </div>
          <div id="courtInputs" class="court-grid" style="margin-top:8px;"></div>
        </div>
      </div>

      <div class="btns">
        <button class="primary" id="generateBtn" type="button">Generate Schedule</button>
        <button class="secondary" id="downloadBtn" type="button">Download HTML</button>
        <button class="secondary" id="printBtn" type="button">Print Sheets</button>
      </div>

      <div id="warnings" class="warnings"></div>
    </div>

    <details open>
      <summary>Schedule + Score Entry</summary>
      <div id="scheduleOut"></div>
    </details>

    <details open id="leaderboardSection">
      <summary>Leaderboard (Wins, Point Differential, Total Points Scored)</summary>
      <div class="btns">
        <button class="primary" id="finalizeRankingsBtn" type="button">Finalize Rankings</button>
        <button class="secondary hidden" id="applyRoundToLeagueBtn" type="button">Add This Round Robin to League Totals</button>
      </div>
      <div id="scoreStatus" class="hint" style="margin-top:6px;"></div>
      <div id="rankOut"></div>
    </details>

    <details open id="leagueStandingsSection" class="hidden">
      <summary>League Overall Standings</summary>
      <div id="leagueStandingsOut"></div>
    </details>
  </div>

  <script>
    const LEAGUE_STORAGE_KEY = "pickleball_league_v1";

    function xmur3(str) {
      let h = 1779033703 ^ str.length;
      for (let i = 0; i < str.length; i++) {
        h = Math.imul(h ^ str.charCodeAt(i), 3432918353);
        h = (h << 13) | (h >>> 19);
      }
      return function () {
        h = Math.imul(h ^ (h >>> 16), 2246822507);
        h = Math.imul(h ^ (h >>> 13), 3266489909);
        return (h ^ (h >>> 16)) >>> 0;
      };
    }

    function sfc32(a, b, c, d) {
      return function () {
        a |= 0;
        b |= 0;
        c |= 0;
        d |= 0;
        const t = ((a + b) | 0) + d | 0;
        d = (d + 1) | 0;
        a = b ^ (b >>> 9);
        b = (c + (c << 3)) | 0;
        c = (c << 21) | (c >>> 11);
        c = (c + t) | 0;
        return (t >>> 0) / 4294967296;
      };
    }

    function seededRandom(seed) {
      if (!seed) return Math.random;
      const gen = xmur3(seed + "::pickle");
      return sfc32(gen(), gen(), gen(), gen());
    }

    function shuffle(arr, rand) {
      for (let i = arr.length - 1; i > 0; i--) {
        const j = Math.floor(rand() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
      return arr;
    }

    function pairKey(a, b) {
      return a < b ? a + "|" + b : b + "|" + a;
    }

    function parseNames(raw) {
      const bits = raw.split(/[\n,;]+/).map((s) => s.trim()).filter(Boolean);
      const out = [];
      const seen = new Set();
      for (const n of bits) {
        if (!seen.has(n)) {
          seen.add(n);
          out.push(n);
        }
      }
      return out;
    }

    function createCourtInputs() {
      const n = Math.max(1, parseInt(document.getElementById("courtCount").value || "1", 10));
      const wrap = document.getElementById("courtInputs");
      const existing = [];
      for (let i = 0; i < wrap.children.length; i++) {
        const el = wrap.children[i].querySelector("input");
        existing.push(el ? el.value : "");
      }

      wrap.innerHTML = "";
      for (let i = 0; i < n; i++) {
        const div = document.createElement("div");
        div.className = "court-row";

        const label = document.createElement("label");
        label.textContent = "Court " + (i + 1) + " name";
        label.setAttribute("for", "court_" + i);

        const input = document.createElement("input");
        input.type = "text";
        input.id = "court_" + i;
        input.placeholder = "Court " + (i + 1);
        input.value = existing[i] || "";

        div.appendChild(label);
        div.appendChild(input);
        wrap.appendChild(div);
      }
    }

    function getCourtNames() {
      const n = Math.max(1, parseInt(document.getElementById("courtCount").value || "1", 10));
      const out = [];
      for (let i = 0; i < n; i++) {
        const v = (document.getElementById("court_" + i)?.value || "").trim();
        out.push(v || ("Court " + (i + 1)));
      }
      return out;
    }

    function getPlayers() {
      const raw = (document.getElementById("playerNames").value || "").trim();
      if (raw) return parseNames(raw);
      const n = Math.max(4, parseInt(document.getElementById("playerCount").value || "4", 10));
      return Array.from({ length: n }, (_, i) => String(i + 1));
    }

    function lexLess(a, b) {
      for (let i = 0; i < Math.max(a.length, b.length); i++) {
        const av = a[i] || 0;
        const bv = b[i] || 0;
        if (av < bv) return true;
        if (av > bv) return false;
      }
      return false;
    }

    function chooseSitters(players, activeTarget, sitCounts, satLastRound, rand) {
      const needSit = Math.max(0, players.length - activeTarget);
      if (needSit === 0) return { sitters: [], active: players.slice() };

      const scored = players.map((p) => ({
        p,
        sits: sitCounts.get(p) || 0,
        satLast: satLastRound.has(p) ? 1 : 0,
        tie: rand(),
      }));

      scored.sort((a, b) => {
        if (a.sits !== b.sits) return a.sits - b.sits;
        if (a.satLast !== b.satLast) return a.satLast - b.satLast;
        return a.tie - b.tie;
      });

      const sitters = scored.slice(0, needSit).map((x) => x.p);
      const sitSet = new Set(sitters);
      const active = players.filter((p) => !sitSet.has(p));
      return { sitters, active };
    }

    function optimalTeams(active, teammateCounts, rand) {
      const n = active.length;
      const fullMask = (1 << n) - 1;
      const memo = new Map();

      function edgeCost(i, j) {
        const a = active[i];
        const b = active[j];
        const used = teammateCounts.get(pairKey(a, b)) || 0;
        return [used > 0 ? 1 : 0, used, rand() * 0.0001];
      }

      function solve(mask) {
        if (mask === 0) return { cost: [0, 0, 0], pairs: [] };
        if (memo.has(mask)) return memo.get(mask);

        let i = 0;
        while (((mask >> i) & 1) === 0) i++;

        let best = null;
        const maskWithoutI = mask & ~(1 << i);

        for (let j = i + 1; j < n; j++) {
          if (((maskWithoutI >> j) & 1) === 0) continue;
          const nextMask = maskWithoutI & ~(1 << j);
          const sub = solve(nextMask);
          const ec = edgeCost(i, j);
          const total = [sub.cost[0] + ec[0], sub.cost[1] + ec[1], sub.cost[2] + ec[2]];
          const cand = {
            cost: total,
            pairs: [[active[i], active[j]]].concat(sub.pairs),
          };
          if (!best || lexLess(cand.cost, best.cost)) best = cand;
        }

        memo.set(mask, best);
        return best;
      }

      return solve(fullMask);
    }

    function optimalMatches(teams, opponentCounts, rand) {
      const n = teams.length;
      const fullMask = (1 << n) - 1;
      const memo = new Map();

      function matchCost(i, j) {
        const t1 = teams[i];
        const t2 = teams[j];
        const cross = [
          [t1[0], t2[0]], [t1[0], t2[1]],
          [t1[1], t2[0]], [t1[1], t2[1]],
        ];

        let repeated = 0;
        let total = 0;
        for (const [a, b] of cross) {
          const c = opponentCounts.get(pairKey(a, b)) || 0;
          if (c > 0) repeated++;
          total += c;
        }
        return [repeated, total, rand() * 0.0001];
      }

      function solve(mask) {
        if (mask === 0) return { cost: [0, 0, 0], pairs: [] };
        if (memo.has(mask)) return memo.get(mask);

        let i = 0;
        while (((mask >> i) & 1) === 0) i++;

        let best = null;
        const m2 = mask & ~(1 << i);

        for (let j = i + 1; j < n; j++) {
          if (((m2 >> j) & 1) === 0) continue;
          const next = m2 & ~(1 << j);
          const sub = solve(next);
          const mc = matchCost(i, j);
          const total = [sub.cost[0] + mc[0], sub.cost[1] + mc[1], sub.cost[2] + mc[2]];
          const cand = {
            cost: total,
            pairs: [[teams[i], teams[j]]].concat(sub.pairs),
          };
          if (!best || lexLess(cand.cost, best.cost)) best = cand;
        }

        memo.set(mask, best);
        return best;
      }

      return solve(fullMask);
    }

    function assignCourts(games, courtNames, courtCounts, rand) {
      const g = games.length;
      const c = courtNames.length;

      if (g === 0) return [];
      if (g === 1) return [{ game: games[0], court: courtNames[Math.floor(rand() * c)] }];

      if (c > 24) {
        const unused = courtNames.slice();
        const assigned = [];
        for (const game of games) {
          let bestIdx = 0;
          let bestCost = Infinity;
          for (let i = 0; i < unused.length; i++) {
            const court = unused[i];
            const players = game[0].concat(game[1]);
            let cost = 0;
            for (const p of players) cost += courtCounts.get(p)?.get(court) || 0;
            if (cost < bestCost) {
              bestCost = cost;
              bestIdx = i;
            }
          }
          assigned.push({ game, court: unused[bestIdx] });
          unused.splice(bestIdx, 1);
        }
        return assigned;
      }

      const memo = new Map();
      function costFor(game, court) {
        const players = game[0].concat(game[1]);
        let cost = 0;
        for (const p of players) cost += courtCounts.get(p)?.get(court) || 0;
        return cost;
      }

      function solve(idx, usedMask) {
        const key = idx + "::" + usedMask;
        if (memo.has(key)) return memo.get(key);
        if (idx === g) return { cost: [0, 0], picks: [] };

        let best = null;
        for (let ci = 0; ci < c; ci++) {
          if ((usedMask >> ci) & 1) continue;
          const court = courtNames[ci];
          const local = costFor(games[idx], court);
          const sub = solve(idx + 1, usedMask | (1 << ci));
          const cand = {
            cost: [local + sub.cost[0], sub.cost[1] + rand() * 0.0001],
            picks: [ci].concat(sub.picks),
          };
          if (!best || lexLess(cand.cost, best.cost)) best = cand;
        }

        memo.set(key, best);
        return best;
      }

      const solved = solve(0, 0);
      return solved.picks.map((ci, i) => ({ game: games[i], court: courtNames[ci] }));
    }

    function pickServeReceive(teamA, teamB, serveCounts, receiveCounts, rand) {
      function orientationCost(serveTeam, receiveTeam) {
        let cost = 0;
        for (const p of serveTeam) {
          const afterServe = (serveCounts.get(p) || 0) + 1;
          const afterRecv = receiveCounts.get(p) || 0;
          cost += Math.abs(afterServe - afterRecv);
        }
        for (const p of receiveTeam) {
          const afterServe = serveCounts.get(p) || 0;
          const afterRecv = (receiveCounts.get(p) || 0) + 1;
          cost += Math.abs(afterServe - afterRecv);
        }
        return cost;
      }

      const c1 = orientationCost(teamA, teamB);
      const c2 = orientationCost(teamB, teamA);

      if (c1 < c2) return { serve: teamA, receive: teamB };
      if (c2 < c1) return { serve: teamB, receive: teamA };
      return rand() < 0.5 ? { serve: teamA, receive: teamB } : { serve: teamB, receive: teamA };
    }

    function buildScheduleCandidate(players, courtNames, rounds, seed) {
      const rand = seededRandom(seed);
      const allPlayers = players.slice();
      const courtCount = courtNames.length;
      const gamesPerRound = Math.min(courtCount, Math.floor(allPlayers.length / 4));
      const activeTarget = gamesPerRound * 4;

      const teammateCounts = new Map();
      const opponentCounts = new Map();
      const sitCounts = new Map(allPlayers.map((p) => [p, 0]));
      const serveCounts = new Map(allPlayers.map((p) => [p, 0]));
      const receiveCounts = new Map(allPlayers.map((p) => [p, 0]));
      const courtCounts = new Map(allPlayers.map((p) => [p, new Map()]));
      const courtOrder = new Map(courtNames.map((name, idx) => [name, idx]));
      const satLastRound = new Set();

      const roundsOut = [];
      for (let r = 1; r <= rounds; r++) {
        const { sitters, active } = chooseSitters(allPlayers, activeTarget, sitCounts, satLastRound, rand);

        satLastRound.clear();
        for (const p of sitters) {
          sitCounts.set(p, (sitCounts.get(p) || 0) + 1);
          satLastRound.add(p);
        }

        shuffle(active, rand);
        const teams = optimalTeams(active, teammateCounts, rand).pairs;
        const games = optimalMatches(teams, opponentCounts, rand).pairs;
        const assigned = assignCourts(games, courtNames, courtCounts, rand);

        const gamesOut = [];
        for (const slot of assigned) {
          const teamA = slot.game[0];
          const teamB = slot.game[1];
          const sides = pickServeReceive(teamA, teamB, serveCounts, receiveCounts, rand);
          const serve = sides.serve.slice();
          const receive = sides.receive.slice();

          teammateCounts.set(pairKey(serve[0], serve[1]), (teammateCounts.get(pairKey(serve[0], serve[1])) || 0) + 1);
          teammateCounts.set(pairKey(receive[0], receive[1]), (teammateCounts.get(pairKey(receive[0], receive[1])) || 0) + 1);

          for (const s of serve) serveCounts.set(s, (serveCounts.get(s) || 0) + 1);
          for (const q of receive) receiveCounts.set(q, (receiveCounts.get(q) || 0) + 1);

          for (const a of serve) {
            for (const b of receive) {
              const ok = pairKey(a, b);
              opponentCounts.set(ok, (opponentCounts.get(ok) || 0) + 1);
            }
          }

          for (const p of serve.concat(receive)) {
            const cm = courtCounts.get(p);
            cm.set(slot.court, (cm.get(slot.court) || 0) + 1);
          }

          gamesOut.push({
            court: slot.court,
            serve,
            receive,
            scoreServe: "",
            scoreReceive: "",
          });
        }

        gamesOut.sort((a, b) => (courtOrder.get(a.court) ?? 9999) - (courtOrder.get(b.court) ?? 9999));
        roundsOut.push({ round: r, sitters, games: gamesOut });
      }

      let repeatedPairTypes = 0;
      let repeatedPairInstances = 0;
      for (const c of teammateCounts.values()) {
        if (c > 1) {
          repeatedPairTypes += 1;
          repeatedPairInstances += (c - 1);
        }
      }

      let repeatedOpponentInstances = 0;
      for (const c of opponentCounts.values()) {
        if (c > 1) repeatedOpponentInstances += (c - 1);
      }

      return {
        players: allPlayers,
        rounds: roundsOut,
        metric: [repeatedPairInstances, repeatedPairTypes, repeatedOpponentInstances],
      };
    }

    function buildSchedule(players, courtNames, rounds, seed) {
      if (players.length < 4) throw new Error("Need at least 4 players.");
      const gamesPerRound = Math.min(courtNames.length, Math.floor(players.length / 4));
      if (gamesPerRound === 0) throw new Error("Need at least one full game (4 players).");

      const attempts = Math.max(40, Math.min(220, rounds * 30));
      let best = null;
      for (let i = 0; i < attempts; i++) {
        const candidateSeed = (seed || "auto") + "::try::" + i;
        const cand = buildScheduleCandidate(players, courtNames, rounds, candidateSeed);
        if (!best || lexLess(cand.metric, best.metric)) best = cand;
      }

      const warnings = [];
      if (best.metric[0] > 0) {
        warnings.push("Some partner repeats were unavoidable for the selected players/courts/rounds.");
      } else {
        warnings.push("No teammate pair repeated across the generated rounds.");
      }

      return {
        players: best.players,
        rounds: best.rounds,
        warnings,
      };
    }

    function renderSchedule(schedule) {
      const host = document.getElementById("scheduleOut");
      host.innerHTML = "";

      if (!schedule || !schedule.rounds.length) {
        host.innerHTML = '<div class="hint">No schedule generated.</div>';
        return;
      }

      for (let r = 0; r < schedule.rounds.length; r++) {
        const round = schedule.rounds[r];
        const sec = document.createElement("section");
        sec.className = "round-sheet";
        sec.style.marginBottom = "14px";

        const h = document.createElement("h3");
        h.textContent = "Round " + round.round;
        sec.appendChild(h);

        const sit = document.createElement("div");
        sit.className = "sit";
        sit.textContent = round.sitters.length ? ("Sitting out: " + round.sitters.join(", ")) : "Sitting out: none";
        sec.appendChild(sit);

        const table = document.createElement("table");
        const thead = document.createElement("thead");
        thead.innerHTML = "<tr><th>Court</th><th>Serve Team</th><th>Receive Team</th><th>Score (Serve)</th><th>Score (Receive)</th></tr>";
        table.appendChild(thead);

        const tbody = document.createElement("tbody");
        for (let g = 0; g < round.games.length; g++) {
          const game = round.games[g];
          const tr = document.createElement("tr");

          const tdCourt = document.createElement("td");
          tdCourt.textContent = game.court;
          tr.appendChild(tdCourt);

          const tdServe = document.createElement("td");
          tdServe.innerHTML = '<span class="tag serve">Serve</span> ' + game.serve.join(", ");
          tr.appendChild(tdServe);

          const tdRecv = document.createElement("td");
          tdRecv.innerHTML = '<span class="tag recv">Receive</span> ' + game.receive.join(", ");
          tr.appendChild(tdRecv);

          const inServe = document.createElement("input");
          inServe.type = "number";
          inServe.min = "0";
          inServe.className = "score-input";
          inServe.value = game.scoreServe;
          inServe.dataset.roundIndex = String(r);
          inServe.dataset.gameIndex = String(g);
          inServe.dataset.side = "serve";

          const tdInServe = document.createElement("td");
          tdInServe.appendChild(inServe);
          tr.appendChild(tdInServe);

          const inRecv = document.createElement("input");
          inRecv.type = "number";
          inRecv.min = "0";
          inRecv.className = "score-input";
          inRecv.value = game.scoreReceive;
          inRecv.dataset.roundIndex = String(r);
          inRecv.dataset.gameIndex = String(g);
          inRecv.dataset.side = "receive";

          const tdInRecv = document.createElement("td");
          tdInRecv.appendChild(inRecv);
          tr.appendChild(tdInRecv);

          tbody.appendChild(tr);
        }

        table.appendChild(tbody);
        sec.appendChild(table);
        host.appendChild(sec);
      }

      host.querySelectorAll("input.score-input").forEach((el) => {
        el.addEventListener("input", onScoreInput);
      });
    }

    function computeLeaderboard(schedule) {
      const stats = new Map(schedule.players.map((p) => [p, { wins: 0, losses: 0, scored: 0, allowed: 0, games: 0 }]));

      for (const round of schedule.rounds) {
        for (const game of round.games) {
          const s = Number(game.scoreServe);
          const r = Number(game.scoreReceive);
          if (!Number.isFinite(s) || !Number.isFinite(r)) continue;
          if (s < 0 || r < 0) continue;

          for (const p of game.serve) {
            const row = stats.get(p);
            row.scored += s;
            row.allowed += r;
            row.games += 1;
            if (s > r) row.wins += 1;
            if (r > s) row.losses += 1;
          }
          for (const p of game.receive) {
            const row = stats.get(p);
            row.scored += r;
            row.allowed += s;
            row.games += 1;
            if (r > s) row.wins += 1;
            if (s > r) row.losses += 1;
          }
        }
      }

      const ranked = Array.from(stats.entries()).map(([name, row]) => {
        const pointDiff = row.scored - row.allowed;
        return {
          name,
          wins: row.wins,
          losses: row.losses,
          scored: row.scored,
          allowed: row.allowed,
          pointDiff,
          games: row.games,
        };
      });

      ranked.sort((a, b) => {
        if (a.wins !== b.wins) return b.wins - a.wins;
        if (a.pointDiff !== b.pointDiff) return b.pointDiff - a.pointDiff;
        if (a.scored !== b.scored) return b.scored - a.scored;
        return a.name.localeCompare(b.name);
      });

      return ranked;
    }

    function getScoreCompletion(schedule) {
      let totalGames = 0;
      let scoredGames = 0;
      for (const round of schedule.rounds) {
        for (const game of round.games) {
          totalGames += 1;
          const s = Number(game.scoreServe);
          const r = Number(game.scoreReceive);
          if (Number.isFinite(s) && Number.isFinite(r) && s >= 0 && r >= 0) scoredGames += 1;
        }
      }
      return { totalGames, scoredGames, missing: totalGames - scoredGames };
    }

    function renderScoreStatus(schedule, forceFinal) {
      const host = document.getElementById("scoreStatus");
      if (!schedule) {
        host.textContent = "No schedule generated.";
        host.className = "hint";
        return;
      }
      const c = getScoreCompletion(schedule);
      if (c.missing === 0) {
        host.textContent = "All games scored. Rankings are ready.";
        host.className = "status-ok";
      } else if (forceFinal) {
        host.textContent = "Final rankings are locked until all games have scores. Missing: " + c.missing + " game(s).";
        host.className = "status-warn";
      } else {
        host.textContent = "Enter all scores, then click Finalize Rankings. Missing: " + c.missing + " game(s).";
        host.className = "hint";
      }
    }

    function renderLeaderboard(schedule) {
      const host = document.getElementById("rankOut");
      host.innerHTML = "";
      if (!schedule) {
        host.innerHTML = '<div class="hint">No schedule generated.</div>';
        return;
      }

      const ranked = computeLeaderboard(schedule);
      const table = document.createElement("table");
      table.innerHTML = "<thead><tr><th>Rank</th><th>Player</th><th>Wins</th><th>Losses</th><th>Point Diff</th><th>Total Points Scored</th><th>Points Allowed</th><th>Games</th></tr></thead>";
      const tbody = document.createElement("tbody");

      ranked.forEach((r, idx) => {
        const tr = document.createElement("tr");
        tr.innerHTML = "<td>" + (idx + 1) + "</td>"
          + "<td>" + r.name + "</td>"
          + "<td class=\"leader-good\">" + r.wins + "</td>"
          + "<td>" + r.losses + "</td>"
          + "<td>" + r.pointDiff + "</td>"
          + "<td>" + r.scored + "</td>"
          + "<td>" + r.allowed + "</td>"
          + "<td>" + r.games + "</td>";
        tbody.appendChild(tr);
      });

      table.appendChild(tbody);
      host.appendChild(table);
    }

    function onScoreInput(e) {
      if (!window.currentSchedule) return;
      const el = e.target;
      const r = parseInt(el.dataset.roundIndex, 10);
      const g = parseInt(el.dataset.gameIndex, 10);
      const side = el.dataset.side;
      const value = el.value.trim();

      if (side === "serve") {
        window.currentSchedule.rounds[r].games[g].scoreServe = value;
      } else {
        window.currentSchedule.rounds[r].games[g].scoreReceive = value;
      }

      renderScoreStatus(window.currentSchedule, window.finalizeRequested);
      if (window.finalizeRequested && getScoreCompletion(window.currentSchedule).missing === 0) {
        renderLeaderboard(window.currentSchedule);
      }
    }

    function runGenerate() {
      const warningsEl = document.getElementById("warnings");
      warningsEl.innerHTML = "";

      try {
        const players = (window.appMode === "league" && window.currentLeague)
          ? window.currentLeague.players.slice()
          : getPlayers();
        const courts = getCourtNames();
        const rounds = Math.max(1, parseInt(document.getElementById("roundCount").value || "1", 10));
        const seed = (document.getElementById("seed").value || "").trim();

        const schedule = buildSchedule(players, courts, rounds, seed);
        window.currentSchedule = schedule;
        window.finalizeRequested = false;

        renderSchedule(schedule);
        renderScoreStatus(schedule, false);
        document.getElementById("rankOut").innerHTML = '<div class="hint">Rankings will appear after you click Finalize Rankings and all games are scored.</div>';

        if (schedule.warnings.length) {
          warningsEl.innerHTML = schedule.warnings.map((w) => "â€¢ " + w).join("<br>");
        }
      } catch (err) {
        window.currentSchedule = null;
        window.finalizeRequested = false;
        document.getElementById("scheduleOut").innerHTML = "";
        document.getElementById("rankOut").innerHTML = "";
        document.getElementById("scoreStatus").textContent = "";
        warningsEl.innerHTML = '<span class="error">' + err.message + "</span>";
      }
    }

    function setSchedulerPlayers(players) {
      document.getElementById("playerCount").value = String(players.length);
      document.getElementById("playerNames").value = players.join("\n");
    }

    function buildEmptyStandings(players) {
      const standings = {};
      for (const p of players) {
        standings[p] = {
          wins: 0,
          losses: 0,
          scored: 0,
          allowed: 0,
          games: 0,
          sessions: 0,
        };
      }
      return standings;
    }

    function computeSessionTotals(schedule) {
      const totals = {};
      for (const p of schedule.players) {
        totals[p] = { wins: 0, losses: 0, scored: 0, allowed: 0, games: 0 };
      }

      for (const round of schedule.rounds) {
        for (const game of round.games) {
          const s = Number(game.scoreServe);
          const r = Number(game.scoreReceive);
          if (!Number.isFinite(s) || !Number.isFinite(r)) continue;
          if (s < 0 || r < 0) continue;

          for (const p of game.serve) {
            totals[p].games += 1;
            totals[p].scored += s;
            totals[p].allowed += r;
            if (s > r) totals[p].wins += 1;
            if (r > s) totals[p].losses += 1;
          }
          for (const p of game.receive) {
            totals[p].games += 1;
            totals[p].scored += r;
            totals[p].allowed += s;
            if (r > s) totals[p].wins += 1;
            if (s > r) totals[p].losses += 1;
          }
        }
      }
      return totals;
    }

    function parseLeagueForm() {
      const name = (document.getElementById("leagueName").value || "").trim();
      if (!name) throw new Error("League name is required.");
      const rawNames = (document.getElementById("leaguePlayerNames").value || "").trim();
      let players = rawNames ? parseNames(rawNames) : [];
      if (!players.length) {
        const n = Math.max(4, parseInt(document.getElementById("leaguePlayerCount").value || "4", 10));
        players = Array.from({ length: n }, (_, i) => String(i + 1));
      }
      if (players.length < 4) throw new Error("League needs at least 4 players.");
      return { name, players };
    }

    function saveLeagueToStorage(league) {
      localStorage.setItem(LEAGUE_STORAGE_KEY, JSON.stringify(league));
    }

    function loadLeagueFromStorage() {
      const raw = localStorage.getItem(LEAGUE_STORAGE_KEY);
      if (!raw) return null;
      try {
        const league = JSON.parse(raw);
        if (!league || !Array.isArray(league.players)) return null;
        return league;
      } catch {
        return null;
      }
    }

    function renderLeagueStatus(message, isError) {
      const el = document.getElementById("leagueStatus");
      el.textContent = message;
      el.className = isError ? "error" : "hint";
    }

    function renderLeagueStandings() {
      const host = document.getElementById("leagueStandingsOut");
      host.innerHTML = "";
      if (!window.currentLeague) {
        host.innerHTML = '<div class="hint">No league loaded.</div>';
        return;
      }

      const rows = window.currentLeague.players.map((name) => {
        const row = window.currentLeague.standings[name] || { wins: 0, losses: 0, scored: 0, allowed: 0, games: 0, sessions: 0 };
        return {
          name,
          wins: row.wins || 0,
          losses: row.losses || 0,
          scored: row.scored || 0,
          allowed: row.allowed || 0,
          games: row.games || 0,
          sessions: row.sessions || 0,
          diff: (row.scored || 0) - (row.allowed || 0),
        };
      });

      rows.sort((a, b) => {
        if (a.wins !== b.wins) return b.wins - a.wins;
        if (a.diff !== b.diff) return b.diff - a.diff;
        if (a.scored !== b.scored) return b.scored - a.scored;
        return a.name.localeCompare(b.name);
      });

      const table = document.createElement("table");
      table.innerHTML = "<thead><tr><th>Rank</th><th>Player</th><th>Wins</th><th>Losses</th><th>Point Diff</th><th>Points Scored</th><th>Points Allowed</th><th>Games</th><th>Sessions</th></tr></thead>";
      const tbody = document.createElement("tbody");
      rows.forEach((r, idx) => {
        const tr = document.createElement("tr");
        tr.innerHTML = "<td>" + (idx + 1) + "</td>"
          + "<td>" + r.name + "</td>"
          + "<td class=\"leader-good\">" + r.wins + "</td>"
          + "<td>" + r.losses + "</td>"
          + "<td>" + r.diff + "</td>"
          + "<td>" + r.scored + "</td>"
          + "<td>" + r.allowed + "</td>"
          + "<td>" + r.games + "</td>"
          + "<td>" + r.sessions + "</td>";
        tbody.appendChild(tr);
      });
      table.appendChild(tbody);
      host.appendChild(table);
    }

    function loadLeagueIntoForm(league) {
      document.getElementById("leagueName").value = league.name || "";
      document.getElementById("leaguePlayerCount").value = String(league.players.length || 4);
      document.getElementById("leaguePlayerNames").value = (league.players || []).join("\n");
    }

    function switchMode(mode) {
      window.appMode = mode;
      const isLeague = mode === "league";

      document.getElementById("modeRoundRobinBtn").classList.toggle("active", !isLeague);
      document.getElementById("modeLeagueBtn").classList.toggle("active", isLeague);
      document.getElementById("leaguePanel").classList.toggle("hidden", !isLeague);
      document.getElementById("leagueStandingsSection").classList.toggle("hidden", !isLeague);
      document.getElementById("applyRoundToLeagueBtn").classList.toggle("hidden", !isLeague);
      document.getElementById("modeHint").textContent = isLeague
        ? "League Play mode is active. Schedules use your loaded league player list."
        : "Round Robin mode is active.";

      if (isLeague && window.currentLeague) {
        setSchedulerPlayers(window.currentLeague.players);
      }
      renderLeagueStandings();
      renderScoreStatus(window.currentSchedule || null, window.finalizeRequested);
    }

    function downloadHTML() {
      const blob = new Blob([document.documentElement.outerHTML], { type: "text/html" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = "pickleball_round_scheduler_scored_rankings.html";
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
    }

    document.getElementById("courtCount").addEventListener("change", createCourtInputs);

    document.getElementById("autofillCourts").addEventListener("click", function () {
      const labels = ["Center", "North", "South", "East", "West", "Pine", "Maple", "River", "Sun", "Hill"];
      const n = Math.max(1, parseInt(document.getElementById("courtCount").value || "1", 10));
      for (let i = 0; i < n; i++) {
        const el = document.getElementById("court_" + i);
        if (el && !el.value.trim()) el.value = labels[i % labels.length] + " Court";
      }
    });

    document.getElementById("fillNumbers").addEventListener("click", function () {
      const n = Math.max(4, parseInt(document.getElementById("playerCount").value || "4", 10));
      document.getElementById("playerNames").value = Array.from({ length: n }, (_, i) => String(i + 1)).join("\n");
    });

    document.getElementById("sampleNames").addEventListener("click", function () {
      const samples = ["Alex", "Bri", "Casey", "Drew", "Evan", "Frankie", "Gray", "Harper", "Indy", "Jules", "Kai", "London", "Morgan", "Noah", "Oakley", "Parker"];
      const n = Math.max(4, parseInt(document.getElementById("playerCount").value || "8", 10));
      document.getElementById("playerNames").value = samples.slice(0, Math.min(n, samples.length)).join(", ");
    });

    document.getElementById("clearNames").addEventListener("click", function () {
      document.getElementById("playerNames").value = "";
    });
    document.getElementById("modeRoundRobinBtn").addEventListener("click", function () {
      switchMode("roundRobin");
    });
    document.getElementById("modeLeagueBtn").addEventListener("click", function () {
      switchMode("league");
    });
    document.getElementById("createLeagueBtn").addEventListener("click", function () {
      try {
        const form = parseLeagueForm();
        const existing = loadLeagueFromStorage();
        const existingStandings = (existing && existing.name === form.name) ? existing.standings : null;
        const standings = buildEmptyStandings(form.players);
        if (existingStandings) {
          for (const p of form.players) {
            if (existingStandings[p]) standings[p] = existingStandings[p];
          }
        }
        window.currentLeague = {
          name: form.name,
          players: form.players,
          standings,
          updatedAt: new Date().toISOString(),
        };
        saveLeagueToStorage(window.currentLeague);
        loadLeagueIntoForm(window.currentLeague);
        setSchedulerPlayers(window.currentLeague.players);
        renderLeagueStandings();
        renderLeagueStatus("League saved: " + form.name + " (" + form.players.length + " players).", false);
      } catch (err) {
        renderLeagueStatus(err.message, true);
      }
    });
    document.getElementById("loadLeagueBtn").addEventListener("click", function () {
      const league = loadLeagueFromStorage();
      if (!league) {
        renderLeagueStatus("No saved league found in this browser.", true);
        return;
      }
      window.currentLeague = league;
      loadLeagueIntoForm(league);
      setSchedulerPlayers(league.players);
      renderLeagueStandings();
      renderLeagueStatus("Loaded league: " + league.name + " (" + league.players.length + " players).", false);
    });
    document.getElementById("clearLeagueBtn").addEventListener("click", function () {
      localStorage.removeItem(LEAGUE_STORAGE_KEY);
      window.currentLeague = null;
      document.getElementById("leagueName").value = "";
      document.getElementById("leaguePlayerNames").value = "";
      document.getElementById("leaguePlayerCount").value = "12";
      renderLeagueStandings();
      renderLeagueStatus("League reset. Saved league removed from browser storage.", false);
    });
    document.getElementById("useLeaguePlayersBtn").addEventListener("click", function () {
      if (!window.currentLeague) {
        renderLeagueStatus("Load or create a league first.", true);
        return;
      }
      setSchedulerPlayers(window.currentLeague.players);
      renderLeagueStatus("Scheduler now uses league player names.", false);
    });

    document.getElementById("generateBtn").addEventListener("click", runGenerate);
    document.getElementById("downloadBtn").addEventListener("click", downloadHTML);
    document.getElementById("printBtn").addEventListener("click", function () {
      window.print();
    });
    document.getElementById("finalizeRankingsBtn").addEventListener("click", function () {
      if (!window.currentSchedule) return;
      window.finalizeRequested = true;
      const c = getScoreCompletion(window.currentSchedule);
      renderScoreStatus(window.currentSchedule, true);
      if (c.missing === 0) {
        renderLeaderboard(window.currentSchedule);
      } else {
        document.getElementById("rankOut").innerHTML = '<div class="hint">Final rankings are waiting for all game scores.</div>';
      }
    });
    document.getElementById("applyRoundToLeagueBtn").addEventListener("click", function () {
      if (window.appMode !== "league") return;
      if (!window.currentLeague) {
        renderLeagueStatus("Create or load a league first.", true);
        return;
      }
      if (!window.currentSchedule) {
        renderLeagueStatus("Generate and score a schedule before adding to league totals.", true);
        return;
      }
      const c = getScoreCompletion(window.currentSchedule);
      if (c.missing > 0) {
        renderLeagueStatus("All schedule games need scores before adding to league totals.", true);
        return;
      }
      if (window.currentSchedule.leagueApplied) {
        renderLeagueStatus("This schedule has already been added to league totals.", true);
        return;
      }

      const sessionTotals = computeSessionTotals(window.currentSchedule);
      for (const p of window.currentLeague.players) {
        if (!window.currentLeague.standings[p]) {
          window.currentLeague.standings[p] = { wins: 0, losses: 0, scored: 0, allowed: 0, games: 0, sessions: 0 };
        }
        const dest = window.currentLeague.standings[p];
        const src = sessionTotals[p] || { wins: 0, losses: 0, scored: 0, allowed: 0, games: 0 };
        dest.wins += src.wins;
        dest.losses += src.losses;
        dest.scored += src.scored;
        dest.allowed += src.allowed;
        dest.games += src.games;
        dest.sessions += 1;
      }
      window.currentLeague.updatedAt = new Date().toISOString();
      window.currentSchedule.leagueApplied = true;
      saveLeagueToStorage(window.currentLeague);
      renderLeagueStandings();
      renderLeagueStatus("Added current schedule results to league totals.", false);
    });

    window.appMode = "roundRobin";
    window.currentLeague = loadLeagueFromStorage();
    window.finalizeRequested = false;
    createCourtInputs();
    if (window.currentLeague) {
      loadLeagueIntoForm(window.currentLeague);
      renderLeagueStatus("Loaded saved league: " + window.currentLeague.name + " (" + window.currentLeague.players.length + " players).", false);
    }
    switchMode("roundRobin");
    runGenerate();
  </script>
</body>
</html>
